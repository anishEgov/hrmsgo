package service

import (
	"context"
	"time"

	"hrms/internal/clients/idgen"
	"hrms/internal/models"
	"hrms/internal/repository"
	"hrms/pkg/errors"

	"github.com/sirupsen/logrus"
)

type employeeService struct {
	repo            repository.EmployeeRepository
	jurisdictionSvc JurisdictionService
	idGenClient     idgen.Client
}

// NewEmployeeService creates a new employee service
func NewEmployeeService(repo repository.EmployeeRepository, jurisdictionSvc JurisdictionService, idGenClient idgen.Client) EmployeeService {

	return &employeeService{
		repo:            repo,
		jurisdictionSvc: jurisdictionSvc,
		idGenClient:     idGenClient,
	}
}

// generateEmployeeCode generates a new employee code using the ID generation service
func (s *employeeService) generateEmployeeCode(ctx context.Context, tenantID string) (string, error) {
	ids, err := s.idGenClient.GenerateIDs(ctx, tenantID, 1, nil)
	if err != nil {
		return "", errors.Wrap(err, "ID_GENERATION_ERROR", "failed to generate employee code").WithOperation("generateEmployeeCode")
	}
	if len(ids) == 0 {
		return "", errors.New("ID_GENERATION_ERROR", "no ID generated").WithOperation("generateEmployeeCode")
	}
	return ids[0], nil
}

// toEmployeeResponse converts an Employee model to EmployeeResponse
func toEmployeeResponse(emp *models.Employee, jurisdictionSvc JurisdictionService, tenantID string) (*models.EmployeeResponse, error) {
	if emp == nil {
		return nil, nil
	}

	// Get jurisdictions for the employee
	var jurisdictions []*models.JurisdictionResponse
	if jurisdictionSvc != nil {
		// Search for jurisdictions by employee ID
		criteria := &models.JurisdictionSearchCriteria{
			EmployeeIDs: []string{emp.ID},
			TenantID:    tenantID,
		}
		jurs, err := jurisdictionSvc.SearchJurisdictions(context.Background(), criteria)
		if err != nil {
			logrus.WithError(err).Error("Failed to fetch jurisdictions for employee")
			// Continue without jurisdictions if there's an error
		}
		jurisdictions = jurs
	}

	return &models.EmployeeResponse{
		ID:                emp.ID,
		Code:              emp.Code,
		UserID:            emp.UserID,
		IndividualID:      emp.IndividualID,
		Status:            emp.Status,
		EmployeeType:      emp.EmployeeType,
		DateOfAppointment: emp.DateOfAppointment,
		Department:        emp.Department,
		Designation:       emp.Designation,
		IsActive:          emp.IsActive,
		Jurisdictions:     jurisdictions,
	}, nil
}

// CreateEmployees creates one or more employees
func (s *employeeService) CreateEmployees(ctx context.Context, req []*models.CreateEmployeeRequest, tenantID string) ([]*models.EmployeeResponse, error) {
	responses := make([]*models.EmployeeResponse, 0, len(req))

	for _, r := range req {
		// Generate employee code
		code, err := s.generateEmployeeCode(ctx, tenantID)
		if err != nil {
			logrus.WithError(err).Error("Failed to generate employee code")
			return nil, errors.Wrap(err, "ID_GENERATION_ERROR", "failed to generate employee code").WithOperation("CreateEmployees")
		}

		// Map request to employee model
		now := time.Now().Unix()
		employee := &models.Employee{
			ID:                "", // Will be generated by the database
			Code:              code,
			UserID:            r.UserID,
			IndividualID:      r.IndividualID,
			Status:            r.Status,
			EmployeeType:      r.EmployeeType,
			DateOfAppointment: r.DateOfAppointment,
			Department:        r.Department,
			Designation:       r.Designation,
			IsActive:          true,
			TenantID:          tenantID,
			CreatedBy:         "system", // TODO: Replace with actual user from context
			CreatedTime:       now,
		}

		// Set IsActive from request if provided
		if r.IsActive != nil {
			employee.IsActive = *r.IsActive
		}

		// Save to database
		if err := s.repo.Create(ctx, employee); err != nil {
			logrus.WithError(err).Error("Failed to create employee")
			return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to create employee").WithOperation("CreateEmployees")
		}

		// Create jurisdictions if provided
		if len(r.Jurisdictions) > 0 {
			for _, j := range r.Jurisdictions {
				jurisReq := &models.CreateJurisdictionRequest{
					EmployeeID:       employee.ID,
					BoundaryRelation: j.BoundaryRelation,
					IsActive:         &j.IsActive,
				}

				_, err := s.jurisdictionSvc.CreateJurisdiction(ctx, jurisReq, tenantID)
				if err != nil {
					logrus.WithError(err).Error("Failed to create jurisdiction for employee")
					// Continue with employee creation even if jurisdiction creation fails
				}
			}
		}

		// Get the employee with jurisdictions
		temp, err := s.repo.FindByUUID(ctx, employee.ID, tenantID)
		if err != nil {
			logrus.WithError(err).Error("Failed to fetch created employee")
			return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to fetch created employee").WithOperation("CreateEmployees")
		}

		resp, err := toEmployeeResponse(temp, s.jurisdictionSvc, tenantID)
		if err != nil {
			logrus.WithError(err).Error("Failed to convert employee to response")
			continue
		}
		responses = append(responses, resp)
	}

	return responses, nil
}

// SearchEmployees searches for employees based on criteria
func (s *employeeService) SearchEmployees(ctx context.Context, criteria *models.EmployeeSearchCriteria) ([]*models.EmployeeResponse, error) {
	employees, err := s.repo.Search(ctx, criteria)
	if err != nil {
		logrus.WithError(err).Error("Failed to search employees")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to search employees").WithOperation("SearchEmployees")
	}

	responses := make([]*models.EmployeeResponse, 0, len(employees))
	for _, emp := range employees {
		resp, err := toEmployeeResponse(emp, s.jurisdictionSvc, criteria.TenantID)
		if err != nil {
			logrus.WithError(err).Error("Failed to convert employee to response")
			continue
		}
		responses = append(responses, resp)
	}

	return responses, nil
}

// GetEmployeeByUUID retrieves an employee by UUID
func (s *employeeService) GetEmployeeByUUID(ctx context.Context, uuid, tenantID string) (*models.EmployeeResponse, error) {
	employee, err := s.repo.FindByUUID(ctx, uuid, tenantID)
	if err != nil {
		if errors.Is(err, errors.ErrNotFound) {
			return nil, errors.ErrNotFound.WithDescription("employee not found").WithOperation("GetEmployeeByUUID")
		}
		logrus.WithError(err).Error("Failed to get employee by UUID")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to get employee").WithOperation("GetEmployeeByUUID")
	}

	return toEmployeeResponse(employee, s.jurisdictionSvc, tenantID)
}

// UpdateEmployee (PUT) replaces an employee by UUID
func (s *employeeService) UpdateEmployee(ctx context.Context, uuid string, req *models.CreateEmployeeRequest, tenantID string) (*models.EmployeeResponse, error) {
	// Get existing employee
	existing, err := s.repo.FindByUUID(ctx, uuid, tenantID)
	if err != nil {
		if errors.Is(err, errors.ErrNotFound) {
			return nil, errors.ErrNotFound.WithDescription("employee not found").WithOperation("UpdateEmployee")
		}
		logrus.WithError(err).Error("Failed to find employee")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to find employee").WithOperation("UpdateEmployee")
	}

	// 1. Delete existing jurisdictions
	jurs, err := s.jurisdictionSvc.SearchJurisdictions(ctx, &models.JurisdictionSearchCriteria{EmployeeIDs: []string{existing.ID}, TenantID: tenantID})
	if err != nil {
		logrus.WithError(err).Error("Failed to fetch jurisdictions for deletion")
	} else {
		for _, jur := range jurs {
			if err := s.jurisdictionSvc.DeleteJurisdiction(ctx, jur.ID, tenantID); err != nil {
				logrus.WithError(err).Error("Failed to delete jurisdiction")
			}
		}
	}

	// 2. Create new jurisdictions
	if len(req.Jurisdictions) > 0 {
		for _, j := range req.Jurisdictions {
			jurisReq := &models.CreateJurisdictionRequest{
				EmployeeID:       existing.ID,
				BoundaryRelation: j.BoundaryRelation,
				IsActive:         &j.IsActive,
			}

			_, err := s.jurisdictionSvc.CreateJurisdiction(ctx, jurisReq, tenantID)
			if err != nil {
				logrus.WithError(err).Error("Failed to create jurisdiction for employee")
				// Continue with employee creation even if jurisdiction creation fails
			}
		}
	}

	// Replace fields
	existing.Code = req.Code
	existing.UserID = req.UserID
	existing.IndividualID = req.IndividualID
	existing.Status = req.Status
	existing.EmployeeType = req.EmployeeType
	existing.DateOfAppointment = req.DateOfAppointment
	existing.Department = req.Department
	existing.Designation = req.Designation
	if req.IsActive != nil {
		existing.IsActive = *req.IsActive
	}

	// Update the last_modified_time
	now := time.Now().Unix()
	existing.LastModifiedTime = &now

	// Save the updated employee
	if err := s.repo.Update(ctx, existing); err != nil {
		logrus.WithError(err).Error("Failed to update employee")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to update employee").WithOperation("UpdateEmployee")
	}

	// Return the updated employee
	return toEmployeeResponse(existing, s.jurisdictionSvc, tenantID)
}

// HardDeleteEmployee deletes an employee and their jurisdictions
func (s *employeeService) HardDeleteEmployee(ctx context.Context, uuid, tenantID string) error {
	// First, find and delete all jurisdictions for this employee
	criteria := &models.JurisdictionSearchCriteria{
		EmployeeIDs: []string{uuid},
		TenantID:    tenantID,
	}
	jurs, err := s.jurisdictionSvc.SearchJurisdictions(ctx, criteria)
	if err != nil {
		logrus.WithError(err).Error("Failed to fetch jurisdictions for deletion")
	} else {
		for _, jur := range jurs {
			if err := s.jurisdictionSvc.DeleteJurisdiction(ctx, jur.ID, tenantID); err != nil {
				logrus.WithError(err).Error("Failed to delete jurisdiction")
			}
		}
	}

	// Then delete the employee
	if err := s.repo.Delete(ctx, uuid, tenantID); err != nil {
		if errors.Is(err, errors.ErrNotFound) {
			return errors.ErrNotFound.WithDescription("employee not found").WithOperation("HardDeleteEmployee")
		}
		logrus.WithError(err).Error("Failed to delete employee")
		return errors.Wrap(err, "DATABASE_ERROR", "failed to delete employee").WithOperation("HardDeleteEmployee")
	}

	return nil
}

// PatchEmployee updates specific fields of an employee
func (s *employeeService) PatchEmployee(ctx context.Context, uuid string, req *models.UpdateEmployeeRequest, tenantID string) (*models.EmployeeResponse, error) {
	// Get existing employee
	existing, err := s.repo.FindByUUID(ctx, uuid, tenantID)
	if err != nil {
		if errors.Is(err, errors.ErrNotFound) {
			return nil, errors.ErrNotFound.WithDescription("employee not found").WithOperation("PatchEmployee")
		}
		logrus.WithError(err).Error("Failed to find employee")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to find employee").WithOperation("PatchEmployee")
	}

	// Update fields if they are provided in the request
	if req.EmployeeStatus != nil {
		existing.Status = *req.EmployeeStatus
	}
	if req.EmployeeType != nil {
		existing.EmployeeType = *req.EmployeeType
	}
	if req.IsActive != nil {
		existing.IsActive = *req.IsActive
	}

	// Update the last_modified_time
	now := time.Now().Unix()
	existing.LastModifiedTime = &now

	// Save the updated employee
	if err := s.repo.Update(ctx, existing); err != nil {
		logrus.WithError(err).Error("Failed to patch employee")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to patch employee").WithOperation("PatchEmployee")
	}

	// Return the updated employee
	return toEmployeeResponse(existing, s.jurisdictionSvc, tenantID)
}

// DeactivateEmployee deactivates an employee
func (s *employeeService) DeactivateEmployee(ctx context.Context, uuid string, req *models.DeactivationDetails, tenantID string) (*models.EmployeeResponse, error) {
	// Log the deactivation details
	logrus.WithFields(logrus.Fields{
		"employee_id":    uuid,
		"reason":         req.ReasonForDeactivation,
		"effective_from": req.EffectiveFrom,
		"remarks":        req.Remarks,
	}).Info("Deactivating employee")

	// Update status to inactive
	if err := s.repo.UpdateIsActive(ctx, uuid, false, tenantID); err != nil {
		logrus.WithError(err).Error("Failed to deactivate employee")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to deactivate employee").WithOperation("DeactivateEmployee")
	}

	return s.GetEmployeeByUUID(ctx, uuid, tenantID)
}

// ReactivateEmployee reactivates an employee
func (s *employeeService) ReactivateEmployee(ctx context.Context, uuid string, req *models.ReactivationDetails, tenantID string) (*models.EmployeeResponse, error) {
	// Log the reactivation details
	logrus.WithFields(logrus.Fields{
		"employee_id":             uuid,
		"reason_for_reactivation": req.ReasonForReactivation,
		"effective_from":          req.EffectiveFrom,
		"remarks":                 req.Remarks,
	}).Info("Reactivating employee")

	// Update status to active
	if err := s.repo.UpdateIsActive(ctx, uuid, true, tenantID); err != nil {
		logrus.WithError(err).Error("Failed to reactivate employee")
		return nil, errors.Wrap(err, "DATABASE_ERROR", "failed to reactivate employee").WithOperation("ReactivateEmployee")
	}

	return s.GetEmployeeByUUID(ctx, uuid, tenantID)
}
